1、在Linux系统上经常使用free命令查看系统中内存情况


物理已用内存 = 实际已用内存 - 缓冲 - 缓存
                    =638 - 508

物理空闲内存 = 总物理内存 - 实际已用内存 + 缓冲 +缓存
 
应用程序可用空闲内存 = 总物理内存 -  实际已用内存

应用程序已用内存 = 实际已用内存  -  缓冲  -缓存


2、buffer缓冲和cache缓存的区别

（1）cache：缓存区，是高速缓存，位于CPU和内存之间的容量较小但速度很快的存储器，cache中保存着CPU刚刚用过的数据或循环使用的部分数据，这时从cache中读取数据就会很快，减少CPU等待的时间，
提高了系统的性能。

cache并不是缓存文件，而是缓存块（块是i/o读写最小的单元），cache一般会在I/O请求上，如果多个进程想要访问某个文件，可以把这个文件读入cache中，这样下一个进程获取CPU控制权并访问此文件时，
就会直接从cache中读取，从而提供系统性能。

下次获取数据时直接从内存中获取，不需要再从缓慢的磁盘中获取，从而提供系统的性能。


（2）buffer：缓冲区，用于存储速度不同步的设备或者优先级不同的设备之间传输数据。通过buffer可以减少进程通信需要等待的时间，当存储速度快的设备与存储速度慢的设备进行通信时，
存储慢的数据先把数据存放在buffer中，达到一定程度存储快的设备再读取buffer的数据，在此期间存储快的设备CPU可以干其他的事情。

说白了就是提高内存和硬盘之间数据交换速度的，优化磁盘的写入。

buffer一般是用在写入磁盘的，例如，某个进程要求多个字段被读入，当所有要求的字段被读入之前，那些已经被读入的字段会先放在buffer中。


3、两者的共同点和差异点
（1）共同点：都是属于内存，数据都是临时的，一旦关机数据就会不存在

（2）差异点：
buffer是要写入数据的，cache是读取数据；
buffer数据丢失会影响数据的完整性，源数据不受影响；cache数据丢失不会影响数据完整性，但是会影响系统的性能；
buffer主要是对磁盘数据的缓存，包括对磁盘的读写；cache主要是对文件数据的缓存，包括对文件的读写；参考：https://www.wabks.com/post/563.html

4、查看系统内存的方法
（1）free命令
快速查看内存信息，这个命令就是读取/proc/meminfo

（2）top命令

（3）cat /proc/meminfo
此文件是动态更新的虚拟文件，查看更多的内存信息

（4）vmstat命令
可以观察buffer/cache的变化

5、buffer/cache调优
（1）cache的回收
当系统上可用内存较少时，就会触发内存回收的工作，来释放更多的内存给急需内存的进程使用。
一般情况下，这个释放的操作主要是释放buffer/cache，cache主要是用来做为缓存，所以当内存告急时，就有必要释放cache，释放完作为可使用内存给进程使用。
所以我们认为buffer/cache空间是可以释放，这个理解是对的。

这种释放缓存的方法是有一定成本的。因为清除缓存之前是要保证cache中的数据要和源文件的数据一致，确保一致之后才会进行释放。
所以在清除cache缓存时，系统的IO都是很高的状态，因为内核要对比cache中的数据和磁盘上的数据是否一致。如果不一致，需要写回才能被回收。

除了在内存耗尽时触发buffer/cache的回收，我们也可以人工触发缓存清除的操作。
cat /proc/sys/vm/drop_caches查看下这个文件中的值
然后echo  值  > /proc/sys/vm/drop_caches
这个文件中的值有3个，分别是1  2  3 
echo  1 > /proc/sys/vm/drop_caches代表清除pagecache

echo  2 > /proc/sys/vm/drop_caches代表清除回收slab分配器中的对象

echo  3 > /proc/sys/vm/drop_caches代表清除pagecache和slab分配器中的缓存对象

因buffer/cache占用太高导致系统崩溃的解决办法一般就是手动触发缓存的清除操作。


手动触发缓存回收的操作，只是在这一次回收有用，过一段时间又需要回收，可以通过内核中提供的vm.vfs_cache_pressure参数来控制回收的频率，
值设置范围0-200，默认值是100，值越大回收频率越高。


